(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{68:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return a})),t.d(n,"metadata",(function(){return s})),t.d(n,"rightToc",(function(){return d})),t.d(n,"default",(function(){return p}));var o=t(2),r=t(6),i=(t(0),t(89)),a={id:"encoders",title:"Rotary Encoders",sidebar_label:"Rotary Encoders"},s={unversionedId:"testing_hardware/encoders",id:"testing_hardware/encoders",isDocsHomePage:!1,title:"Rotary Encoders",description:"` python",source:"@site/docs/testing_hardware/encoder.md",slug:"/testing_hardware/encoders",permalink:"/docs/testing_hardware/encoders",editUrl:"https://github.com/jpconstantineau/pykey/tree/main/documentation/docs/testing_hardware/encoder.md",version:"current",sidebar_label:"Rotary Encoders",sidebar:"someSidebar",previous:{title:"Basic GPIOs",permalink:"/docs/testing_hardware/basic"},next:{title:"Analog Input and Outputs",permalink:"/docs/testing_hardware/analog"}},d=[],c={rightToc:d};function p(e){var n=e.components,t=Object(r.a)(e,["components"]);return Object(i.b)("wrapper",Object(o.a)({},c,t,{components:n,mdxType:"MDXLayout"}),Object(i.b)("pre",null,Object(i.b)("code",Object(o.a)({parentName:"pre"},{className:"language-python"}),"import board\nimport rotaryio\n\nencoder = rotaryio.IncrementalEncoder(board.P0_26, board.P0_06)\nlast_position = None\nwhile True:\n    position = encoder.position\n    if last_position is None or position != last_position:\n        print(position)\n    last_position = position\n\n")))}p.isMDXComponent=!0}}]);
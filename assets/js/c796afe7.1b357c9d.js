"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[494],{3905:function(n,e,t){t.d(e,{Zo:function(){return p},kt:function(){return f}});var r=t(7294);function i(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function a(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){i(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function c(n,e){if(null==n)return{};var t,r,i=function(n,e){if(null==n)return{};var t,r,i={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(i[t]=n[t]);return i}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(i[t]=n[t])}return i}var u=r.createContext({}),s=function(n){var e=r.useContext(u),t=e;return n&&(t="function"==typeof n?n(e):a(a({},e),n)),t},p=function(n){var e=s(n.components);return r.createElement(u.Provider,{value:e},n.children)},l={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},d=r.forwardRef((function(n,e){var t=n.components,i=n.mdxType,o=n.originalType,u=n.parentName,p=c(n,["components","mdxType","originalType","parentName"]),d=s(t),f=i,m=d["".concat(u,".").concat(f)]||d[f]||l[f]||o;return t?r.createElement(m,a(a({ref:e},p),{},{components:t})):r.createElement(m,a({ref:e},p))}));function f(n,e){var t=arguments,i=e&&e.mdxType;if("string"==typeof n||i){var o=t.length,a=new Array(o);a[0]=d;var c={};for(var u in e)hasOwnProperty.call(e,u)&&(c[u]=e[u]);c.originalType=n,c.mdxType="string"==typeof n?n:i,a[1]=c;for(var s=2;s<o;s++)a[s]=t[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},3319:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return c},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return p},default:function(){return d}});var r=t(7462),i=t(3366),o=(t(7294),t(3905)),a=["components"],c={id:"findingmatrix",title:"Finding Key Matrix",sidebar_label:"Finding Key Matrix"},u=void 0,s={unversionedId:"testing_hardware/findingmatrix",id:"testing_hardware/findingmatrix",title:"Finding Key Matrix",description:"The following program will list the GPIO names connected to anodes and cathodes of a keyboard matrix. Open up the serial connection to the REPL and press keys in sequence.  Make sure you go through each row and column methodically so that the order printed out makes sense.",source:"@site/docs/testing_hardware/findingmatrix.md",sourceDirName:"testing_hardware",slug:"/testing_hardware/findingmatrix",permalink:"/docs/testing_hardware/findingmatrix",editUrl:"https://github.com/jpconstantineau/pykey/tree/main/documentation/docs/testing_hardware/findingmatrix.md",tags:[],version:"current",frontMatter:{id:"findingmatrix",title:"Finding Key Matrix",sidebar_label:"Finding Key Matrix"},sidebar:"someSidebar",previous:{title:"Finding Buttons",permalink:"/docs/testing_hardware/findingbuttons"},next:{title:"RGB LEDs",permalink:"/docs/testing_hardware/neopixels"}},p=[],l={toc:p};function d(n){var e=n.components,t=(0,i.Z)(n,a);return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The following program will list the GPIO names connected to anodes and cathodes of a keyboard matrix. Open up the serial connection to the REPL and press keys in sequence.  Make sure you go through each row and column methodically so that the order printed out makes sense."),(0,o.kt)("p",null,"If no diodes are in the key matrix, you may see pins listed in both anodes and cathodes.  With this list you will have a starting point on how to configure the keypad scanning routines."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-python"},"\n\nimport board\nimport time\nfrom microcontroller import Pin\nfrom digitalio import DigitalInOut, Direction, Pull\n\ndef get_unique_pins():\n    exclude = ['NEOPIXEL', 'APA102_MOSI', 'APA102_SCK']\n    pins = [pin for pin in [\n        getattr(board, p) for p in dir(board) if p not in exclude]\n            if isinstance(pin, Pin)]\n    unique = []\n    for p in pins:\n        if p not in unique:\n            unique.append(p)\n    return unique\n\npins = []\n\nfor scl_pin in get_unique_pins():\n        pin = DigitalInOut(scl_pin)\n        pin.direction = Direction.INPUT\n        pin.pull = Pull.DOWN\n        if pin not in pins:\n            pins.append([scl_pin, pin])\n\n\nanodes=[]\ncathodes = []\n\nwhile True:\n    for row in pins:\n        row[1].direction = Direction.OUTPUT\n        row[1].value = True\n        for column in pins:\n            if row is column:\n                continue\n            column[1].direction = Direction.INPUT\n            column[1].pull = Pull.DOWN    \n               \n            if column[1].value:\n                if row[0] not in anodes:\n                    anodes.append(row[0])\n                if column[0] not in cathodes:\n                    cathodes.append(column[0])\n    print('anodes', end=' ')\n    print(anodes)\n    print('cathodes', end=' ')\n    print(cathodes)\n    time.sleep(0.2)\n")))}d.isMDXComponent=!0}}]);